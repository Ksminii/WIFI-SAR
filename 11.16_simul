import numpy as np
import math
import time
import matplotlib.pyplot as plt
from dataclasses import dataclass, field
import warnings
warnings.filterwarnings('ignore')  # ëª¨ë“  ê²½ê³  ì°¨ë‹¨


# --------------------------------------------------------------------------
# 1. ìƒìˆ˜ ë° ë°ì´í„° í´ë˜ìŠ¤ ì •ì˜
# --------------------------------------------------------------------------
@dataclass
class Constants:
    INITIAL_DISTANCE: float = 100.0
    MIN_SIGNAL_STRENGTH: float = -100.0
    MIN_DISTANCE_TO_HOTSPOT: float = 1.0
    ROTATION_ANGLE_RAD: float = np.pi / 4


@dataclass
class SimParams:
    TRANSMIT_POWER_DBM: float = 15.0
    DIST_FAR: float = 15.0
    DIST_MID: float = 5.0
    DIST_NEAR: float = 3.0
    DIST_PINPOINT: float = 1.2

    STUCK_THRESHOLD: int = 3
    ESCAPE_DISTANCE: float = 25.0

    SIGNAL_MID: float = -51.0
    SIGNAL_NEAR: float = -45.0
    SIGNAL_PINPOINT: float = -35.0
    ASCENT_THRESHOLD: float = -60.0

    PROBE_DISTANCE: float = 8.0
    GPS_DRIFT_FACTOR: float = 0.8  # 1 ì´ë©´ GPS ì˜¤ì°¨ ì—†ë‹¤ê³  ìƒê°
    ROTATION_PENALTY_TIME: float = 1.5
    DRONE_SPEED: float = 8.0
    RSSI_SCAN_TIME: float = 2.0
    TIME_LIMIT: float = 100000.0
    GPS_ERROR_STD: float = 8.0
    RSSI_SHADOW_STD: float = 1.0
    SENSOR_DELAY_MEAN: float = 0.12
    SENSOR_DELAY_STD: float = 0.02
    SENSOR_ERROR_STD: float = 1.2
    NUM_ESCAPE_SAMPLES: int = 8
    ESCAPE_SAMPLE_RADIUS: float = 20.0

    ### ê´€ì„±(Momentum) íŒŒë¼ë¯¸í„° ###
    MOMENTUM_FACTOR: float = 0.1  # ì„±ê³µ ìŠ¤íŠ¸ë¦¬í¬ ë‹¹ ì´ë™ ì†ë„ ì¦ê°€ëŸ‰
    MAX_MOMENTUM_BOOST: float = 2.5  # ìµœëŒ€ ê°€ì† ë°°ìœ¨
    ##############################

    ### ì§€ìˆ˜ì´ë™í‰ê· _í‰í™œìƒìˆ˜ ###
    """(0~1 ì‚¬ì´ ê°’) ì‹ í˜¸ í•„í„°ë§ ê°•ë„. ë†’ì„ìˆ˜ë¡ í˜„ì¬ ê°’ì— ë¯¼ê°, ë‚®ì„ìˆ˜ë¡ ë‘”ê°."""
    RSSI_SMOOTHING_FACTOR: float = 0.3
    ########################

    # --- í˜ì´ë”© ëª¨ë¸ íŒŒë¼ë¯¸í„° ---
    ENABLE_FADING: bool = True
    RICIAN_K_FACTOR: float = 6.0  # ë¼ì´ì‹œì•ˆ K íŒ©í„° (dB)
    # K > 10: LOS (í˜ì´ë”© ê±°ì˜ ì—†ìŒ)
    # K = 3~10 dB: LOS + ì‚°ë€ í˜¼í•©
    # K â‰ˆ 0.01 dB: ë ˆì´ë¦¬ í˜ì´ë”© (NLOS)


@dataclass
class SimResult:
    """ë‹¨ì¼ ì‹œë®¬ë ˆì´ì…˜ì˜ ê²°ê³¼ë¥¼ ì €ì¥í•˜ëŠ” êµ¬ì¡°ì²´ ì—­í• """
    success: bool
    final_distance: float
    total_travel: float
    search_time: float
    reason: str
    waypoint_count: int
    waypoints_at_threshold: int
    rssi_at_success: float


# --------------------------------------------------------------------------
# 2. Simulation Environment Class
# --------------------------------------------------------------------------
class SimulationEnvironment:
    def __init__(self, params: SimParams):
        if not isinstance(params, SimParams):
            raise TypeError("paramsëŠ” SimParamsì˜ ì¸ìŠ¤í„´ìŠ¤ì—¬ì•¼ í•©ë‹ˆë‹¤.")
        self.params = params
        angle = np.random.uniform(0, 2 * np.pi)
        self.hotspot_pos = np.array([
            Constants.INITIAL_DISTANCE * np.cos(angle),
            Constants.INITIAL_DISTANCE * np.sin(angle)
        ])

    def apply_rician_fading(self, signal_db: float) -> float:
        """
        ë¼ì´ì‹œì•ˆ í˜ì´ë”©ì„ ì‹ í˜¸ì— ì ìš©

        ë¼ì´ì‹œì•ˆ í˜ì´ë”© ëª¨ë¸:
        ìˆ˜ì‹  ì‹ í˜¸ ì§„í­ rì€ ë‹¤ìŒ í™•ë¥  ë°€ë„ í•¨ìˆ˜ë¥¼ ë”°ë¦„:

        f(r) = (r/ÏƒÂ²) * exp(-(rÂ² + sÂ²)/(2ÏƒÂ²)) * Iâ‚€(rs/ÏƒÂ²)

        K-factor ì¡°ì ˆë¡œ ë‹¤ì–‘í•œ í™˜ê²½ í‘œí˜„:
        - K > 10 dB: ìˆœìˆ˜ LOS (í˜ì´ë”© ê±°ì˜ ì—†ìŒ)
        - K = 3~10 dB: LOS + ì‚°ë€ í˜¼í•© í™˜ê²½
        - K â†’ 0 dB: ë ˆì´ë¦¬ í˜ì´ë”© (ìˆœìˆ˜ NLOS)
        """
        if not self.params.ENABLE_FADING:
            return signal_db

        # dBë¥¼ ì„ í˜• ìŠ¤ì¼€ì¼ë¡œ ë³€í™˜
        signal_linear = 10 ** (signal_db / 10)

        # K-factorë¥¼ ì„ í˜• ìŠ¤ì¼€ì¼ë¡œ ë³€í™˜
        K_linear = 10 ** (self.params.RICIAN_K_FACTOR / 10)

        # LOS ì„±ë¶„
        los_component = np.sqrt(K_linear / (K_linear + 1))

        # ì‚°ë€ ì„±ë¶„ì˜ í‘œì¤€í¸ì°¨
        scatter_scale = 1 / np.sqrt(2 * (K_linear + 1))

        # ì‚°ë€ ì„±ë¶„ ìƒì„±
        scatter_real = np.random.normal(0, scatter_scale)  # Nâ‚
        scatter_imag = np.random.normal(0, scatter_scale)  # Nâ‚‚

        # ë³µì†Œ ì§„í­ì˜ í¬ê¸°
        amplitude = np.abs(los_component + scatter_real + 1j * scatter_imag)

        # ìˆ˜ì‹  ì „ë ¥ = ì§„í­Â²
        faded_signal_linear = signal_linear * (amplitude ** 2)

        # ì„ í˜• ìŠ¤ì¼€ì¼ì„ ë‹¤ì‹œ dBë¡œ ë³€í™˜
        if faded_signal_linear > 0:
            return 10 * np.log10(faded_signal_linear)
        else:
            return Constants.MIN_SIGNAL_STRENGTH

    def get_signal(self, pos: np.ndarray, add_noise: bool = True) -> float:
        if not isinstance(pos, np.ndarray) or pos.shape != (2,):
            raise ValueError("ìœ„ì¹˜ëŠ” 2D numpy ë°°ì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤.")

        distance = np.linalg.norm(pos - self.hotspot_pos)
        distance = max(distance, Constants.MIN_DISTANCE_TO_HOTSPOT)
        p_tx = self.params.TRANSMIT_POWER_DBM
        path_loss_db = 30.0 + 20 * np.log10(distance)
        signal = p_tx - path_loss_db

        # ë¼ì´ì‹œì•ˆ í˜ì´ë”© ì ìš©
        signal = self.apply_rician_fading(signal)

        if add_noise:
            shadow_fading = np.random.normal(0, self.params.RSSI_SHADOW_STD)
            signal += shadow_fading
            small_scale_fading = np.random.randn() * 0.5
            signal += small_scale_fading

        return max(Constants.MIN_SIGNAL_STRENGTH, signal)


# --------------------------------------------------------------------------
# 3. HomingAlgorithm Class
# --------------------------------------------------------------------------

class HomingAlgorithm:
    """
    ê´€ì„±(Momentum) ì ìš© í•˜ì´ë¸Œë¦¬ë“œ ì•Œê³ ë¦¬ì¦˜
    Ttm
    """

    def __init__(self, start_pos: np.ndarray, params: SimParams):
        # --- ê³µí†µ ë³€ìˆ˜ ì´ˆê¸°í™” ---
        self.pos, self.waypoint = np.array(start_pos, dtype=float), np.array(start_pos, dtype=float)
        self.path, self.params, self.is_finished = [start_pos.copy()], params, False
        self.state = "SPIRAL"
        self.last_signal, self.stuck_counter = Constants.MIN_SIGNAL_STRENGTH, 0
        self.best_known_pos, self.best_known_signal = self.pos.copy(), Constants.MIN_SIGNAL_STRENGTH
        self.ascent_direction = np.array([1.0, 0.0])
        self.waypoint_count: int = 0

        # --- ë‚˜ì„ í˜• íƒìƒ‰ìš© ë³€ìˆ˜ ---
        self.spiral_waypoint = self.pos.copy()
        self.spiral_leg_length, self.spiral_steps_taken, self.spiral_legs_completed = 1, 0, 0
        self.spiral_direction = np.array([1.0, 0.0])

        # --- ìƒ˜í”Œë§ íƒˆì¶œìš© ë³€ìˆ˜ ---
        self.escape_points, self.escape_results = [], {}
        self.current_escape_point_index, self.stuck_signal_baseline = 0, Constants.MIN_SIGNAL_STRENGTH

        # --- ì‹ í˜¸ í•„í„°ë§(EWMA)ì„ ìœ„í•œ ë³€ìˆ˜ ---
        self.smoothed_rssi = Constants.MIN_SIGNAL_STRENGTH

        # --- ê´€ì„±(Momentum)ì„ ìœ„í•œ ë³€ìˆ˜ ---
        self.success_streak = 0

    def decide_action(self, rssi: float):
        if self.is_finished: return
        self.waypoint_count += 1
        if self.smoothed_rssi == Constants.MIN_SIGNAL_STRENGTH:
            self.smoothed_rssi = rssi
        else:
            alpha = self.params.RSSI_SMOOTHING_FACTOR
            self.smoothed_rssi = (alpha * rssi) + ((1 - alpha) * self.smoothed_rssi)
        if self.smoothed_rssi > self.best_known_signal:
            self.best_known_signal, self.best_known_pos = self.smoothed_rssi, self.pos.copy()

        if self.state == "SPIRAL":
            self._execute_spiral(self.smoothed_rssi)
        elif self.state == "ADAPTIVE_ASCENT":
            self._execute_adaptive_ascent(self.smoothed_rssi)
        elif self.state == "ESCAPING":
            self._execute_escaping(self.smoothed_rssi)

        self.last_signal = self.smoothed_rssi

    def _execute_spiral(self, rssi: float):
        if rssi > self.params.ASCENT_THRESHOLD:
            self.state = "ADAPTIVE_ASCENT"
            self._execute_adaptive_ascent(rssi)
            return
        step_distance = self.params.DIST_FAR
        self.waypoint = self.spiral_waypoint + self.spiral_direction * step_distance
        self.spiral_steps_taken += 1
        if self.spiral_steps_taken >= self.spiral_leg_length:
            self.spiral_steps_taken, self.spiral_legs_completed = 0, self.spiral_legs_completed + 1
            self.spiral_direction = np.array([-self.spiral_direction[1], self.spiral_direction[0]])
            if self.spiral_legs_completed % 2 == 0: self.spiral_leg_length += 1
        self.spiral_waypoint = self.waypoint

    def _execute_adaptive_ascent(self, rssi: float):
        # --- ê´€ì„±(Momentum) ë¡œì§ ì ìš© ---
        if rssi > self.last_signal:
            # ì„±ê³µ ì‹œ: ìŠ¤íŠ¸ë¦¬í¬ ì¦ê°€, stuck ì¹´ìš´í„° ì´ˆê¸°í™”
            self.success_streak += 1
            self.stuck_counter = 0
        else:
            # ì‹¤íŒ¨ ì‹œ: ìŠ¤íŠ¸ë¦¬í¬ ì´ˆê¸°í™”, stuck ì¹´ìš´í„° ì¦ê°€ ë° ë°©í–¥ ì „í™˜
            self.success_streak = 0
            self.stuck_counter += 1
            rot_matrix = np.array([[np.cos(Constants.ROTATION_ANGLE_RAD), -np.sin(Constants.ROTATION_ANGLE_RAD)],
                                   [np.sin(Constants.ROTATION_ANGLE_RAD), np.cos(Constants.ROTATION_ANGLE_RAD)]])
            self.ascent_direction = np.dot(rot_matrix, self.ascent_direction)

        if self.stuck_counter > self.params.STUCK_THRESHOLD:
            self.success_streak = 0  # íƒˆì¶œ ì‹œ ê´€ì„± ì´ˆê¸°í™”
            self._initiate_escaping(rssi)
            self.state = "ESCAPING"
            return

        # ê´€ì„±ì„ ì´ìš©í•œ ë™ì  ì´ë™ ê±°ë¦¬ ê³„ì‚°
        base_step = self._get_adaptive_distance(rssi)
        momentum_boost = 1.0 + (self.success_streak * self.params.MOMENTUM_FACTOR)
        # ìµœëŒ€ ê°€ì† ë°°ìœ¨ ì œí•œ
        momentum_boost = min(momentum_boost, self.params.MAX_MOMENTUM_BOOST)

        final_step = base_step * momentum_boost
        self.waypoint = self.pos + self.ascent_direction * final_step

    def _initiate_escaping(self, current_rssi: float):
        self.stuck_signal_baseline = current_rssi
        self.escape_points, self.escape_results = [], {}
        self.current_escape_point_index = 0
        num_samples, radius = self.params.NUM_ESCAPE_SAMPLES, self.params.ESCAPE_SAMPLE_RADIUS

        mean_angle = np.arctan2(self.ascent_direction[1], self.ascent_direction[0])

        angle_std_dev = np.pi / 4

        for _ in range(num_samples):
            angle = np.random.normal(loc=mean_angle, scale=angle_std_dev)

            r = np.random.uniform(0, radius)
            point = self.best_known_pos + np.array([r * np.cos(angle), r * np.sin(angle)])
            self.escape_points.append(point)

        self.waypoint = self.escape_points[0]

    def _execute_escaping(self, rssi: float):
        if np.linalg.norm(self.pos - self.waypoint) < 2.0:
            if rssi > self.stuck_signal_baseline + 1.0:
                self.ascent_direction = (self.waypoint - self.best_known_pos)
                norm = np.linalg.norm(self.ascent_direction)
                if norm > 0: self.ascent_direction /= norm
                self.state, self.stuck_counter = "ADAPTIVE_ASCENT", 0
                return
            if self.current_escape_point_index >= len(self.escape_points) - 1:
                self.escape_results[self.current_escape_point_index] = rssi
                if self.escape_results:
                    best_point_idx = max(self.escape_results, key=self.escape_results.get)
                    self.waypoint = self.escape_points[best_point_idx]
                self.state, self.stuck_counter = "ADAPTIVE_ASCENT", 0
                return
            self.escape_results[self.current_escape_point_index] = rssi
            self.current_escape_point_index += 1
            self.waypoint = self.escape_points[self.current_escape_point_index]

    def _get_adaptive_distance(self, signal: float) -> float:
        if signal > self.params.SIGNAL_PINPOINT: return self.params.DIST_PINPOINT
        if signal > self.params.SIGNAL_NEAR: return self.params.DIST_NEAR
        if signal > self.params.SIGNAL_MID: return self.params.DIST_MID
        return self.params.DIST_FAR

    def update_position(self, new_pos: np.ndarray):
        self.pos, self.path = new_pos, self.path + [new_pos.copy()]

    def get_total_distance(self) -> float:
        return np.sum(np.linalg.norm(np.diff(np.array(self.path), axis=0), axis=1)) if len(self.path) > 1 else 0.0


# --------------------------------------------------------------------------
# 4. ì‹œê°í™” í´ë˜ìŠ¤
# --------------------------------------------------------------------------
class SimulationVisualizer:
    def __init__(self, time_scale: float = 1.0, view_radius_m: float = 50.0) :
        """
        time_scale: ì‹œë®¬ë ˆì´ì…˜ ì†ë„ ì¡°ì ˆ (1.0 = ì‹¤ì‹œê°„, 0.5 = ì ˆë°˜ ì†ë„, 2.0 = 2ë°° ì†ë„, 5.0 = 5ë°° ì†ë„)
        """
        plt.ion()
        self.fig, self.ax = plt.subplots(figsize=(10, 10))
        self.start_real_time = None
        self.start_simulation_time = None
        self.time_scale = time_scale
        self.view_radius = view_radius_m
        print(f"ğŸ¬ Visualizer initialized with time_scale = {self.time_scale}")  # ë””ë²„ê·¸ìš©
        self.path_history = []  # ê²½ë¡œ íˆìŠ¤í† ë¦¬ ëˆ„ì 
        self.last_real_time = None
        self.last_sim_time = None

    def update(self, env: SimulationEnvironment, true_pos: np.ndarray, reported_pos: np.ndarray, simulation_time: float,
               current_rssi: float, status: str = "Moving", algo_state: str = "INIT", next_waypoint: np.ndarray = None):
        # ì²« ì—…ë°ì´íŠ¸ì¼ ë•Œ ì‹œì‘ ì‹œê°„ ì´ˆê¸°í™”
        if self.start_real_time is None:
            self.start_real_time = time.time()
            self.start_simulation_time = simulation_time

        # ë°°ì† ì ìš©: ì‹œë®¬ë ˆì´ì…˜ ì‹œì‘ ì´í›„ ê²½ê³¼ ì‹œê°„ ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚°
        sim_elapsed_total = simulation_time - self.start_simulation_time
        target_real_elapsed_total = sim_elapsed_total / self.time_scale  # â† ë°°ì† ì ìš©

        # í˜„ì¬ê¹Œì§€ ì‹¤ì œë¡œ ê²½ê³¼í•œ ì‹œê°„
        current_real_time = time.time()
        actual_real_elapsed_total = current_real_time - self.start_real_time

        # í•„ìš”í•œ ë§Œí¼ ëŒ€ê¸° (ì „ì²´ ê¸°ì¤€ìœ¼ë¡œ ë™ê¸°í™”)
        sleep_time = target_real_elapsed_total - actual_real_elapsed_total
        if sleep_time > 0.001:  # 1ms ì´ìƒë§Œ sleep
            time.sleep(sleep_time)

        # ê²½ë¡œ íˆìŠ¤í† ë¦¬ì— í˜„ì¬ ìœ„ì¹˜ ì¶”ê°€
        if len(self.path_history) == 0 or np.linalg.norm(true_pos - np.array(self.path_history[-1])) > 0.1:
            self.path_history.append(true_pos.copy())

        # ê·¸ë˜í”„ ì—…ë°ì´íŠ¸ (ê°„ë‹¨í•˜ê³  ë¹ ë¥´ê²Œ)
        self.ax.clear()

        # ëˆ„ì ëœ ê²½ë¡œ í‘œì‹œ
        if len(self.path_history) > 1:
            path_array = np.array(self.path_history)
            self.ax.plot(path_array[:, 0], path_array[:, 1], 'c-', alpha=0.6, linewidth=1, label='Path')

        # ë“œë¡  í˜„ì¬ ìœ„ì¹˜ (ì‹¤ì œ ìœ„ì¹˜)
        self.ax.plot(true_pos[0], true_pos[1], 'bo', markersize=14, label='Drone (True Pos)', zorder=5)

        # Next Waypoint í‘œì‹œ
        if next_waypoint is not None:
            self.ax.plot(next_waypoint[0], next_waypoint[1], 'go', markersize=10, mfc='none', mew=2,
                         label='Next Waypoint', zorder=3)
            self.ax.plot([true_pos[0], next_waypoint[0]], [true_pos[1], next_waypoint[1]], 'y--', alpha=0.7,
                         linewidth=1.5)

        # ëª©í‘œ (hotspot)
        self.ax.plot(env.hotspot_pos[0], env.hotspot_pos[1], 'r*', markersize=20, label='Hotspot (Goal)', zorder=4)

        # ë“œë¡ ì—ì„œ ëª©í‘œê¹Œì§€ ì„  ê·¸ë¦¬ê¸°
        self.ax.plot([true_pos[0], env.hotspot_pos[0]], [true_pos[1], env.hotspot_pos[1]], 'g--', alpha=0.3,
                     linewidth=1)

        distance_to_goal = np.linalg.norm(true_pos - env.hotspot_pos)
        speed_display = f"x{self.time_scale:.1f}" if self.time_scale != 1.0 else "1x"

        title_line_1 = f"[{algo_state} | {status}]"
        title_line_2 = f"Time: {simulation_time:.1f}s | Dist: {distance_to_goal:.1f}m | RSSI: {current_rssi:.1f} dBm | Speed: {speed_display}"

        self.ax.set_title(title_line_1 + "\n" + title_line_2)
        self.ax.set_xlabel("X (meters)")
        self.ax.set_ylabel("Y (meters)")
        self.ax.grid(True, which='both', linestyle='--', linewidth=0.5, alpha=0.3)
        self.ax.legend(loc='upper right')
        self.ax.axis('equal')

        self.ax.set_xlim(-100, 100)
        self.ax.set_ylim(-100, 100)
        # self.ax.axis('equal')

        drone_x, drone_y = true_pos[0], true_pos[1]
        self.ax.set_xlim(drone_x - self.view_radius, drone_x + self.view_radius)
        self.ax.set_ylim(drone_y - self.view_radius, drone_y + self.view_radius)

        # ìµœì†Œí•œì˜ pause - í™”ë©´ ì—…ë°ì´íŠ¸ë§Œ í•˜ê³  ì§€ì—° ìµœì†Œí™”
        plt.pause(0.00001)  # ê±°ì˜ ë¬´ì‹œí•  ìˆ˜ ìˆëŠ” ìˆ˜ì¤€

    def close(self):
        plt.ioff()
        plt.show()

# --------------------------------------------------------------------------
# 5. ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰ í´ë˜ìŠ¤
# --------------------------------------------------------------------------
class SimulationRunner:
    def __init__(self, params: SimParams):
        self.params = params

    def run_single(self, visualizer: SimulationVisualizer = None) -> SimResult:
        env = SimulationEnvironment(self.params)
        algo = HomingAlgorithm(start_pos=np.array([0.0, 0.0]), params=self.params)

        true_pos = np.array([0.0, 0.0])
        previous_gps_error, previous_direction = np.zeros(2), None
        waypoints_at_threshold_pass, threshold_passed = 0, False

        # --- ì„±ê³µ ì‹œì ì˜ RSSIë¥¼ ê¸°ë¡í•˜ê¸° ìœ„í•œ ë³€ìˆ˜ ---
        rssi_at_success: float = 0.0

        # â–¼â–¼â–¼ [ë³€ê²½ 4] ì„±ê³µ ì„ê³„ê°’ ê³„ì‚° ë¡œì§ ì „ì²´ êµì²´ â–¼â–¼â–¼
        # --- [ìˆ˜ì •] 99.5% percentile ê¸°ë°˜ ë™ì  ì„±ê³µ ì„ê³„ê°’ ê³„ì‚°
        # Monte Carlo ê²€ì¦ëœ ì„ê³„ê°’ ì‚¬ìš© (10,000 samples)
        current_std = self.params.RSSI_SHADOW_STD

        # 99.5% percentile ì„ê³„ê°’ ë§¤í•‘ (Monte Carlo ì¬ê³„ì‚° ê²°ê³¼)
        if self.params.RICIAN_K_FACTOR == 0.0:  # Rayleigh fading (K=0)
            threshold_map = {
                1.0: -26.7,
                3.0: -24.0,
                5.0: -20.2
            }
        else:  # Rician fading (K=6)
            threshold_map = {
                1.0: -28.8,
                3.0: -25.7,
                5.0: -21.2
            }

        # ì •í™•í•œ ë§¤í•‘ì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ë³´ê°„
        if current_std in threshold_map:
            success_threshold_dbm = threshold_map[current_std]
        else:
            # ì„ í˜• ë³´ê°„
            keys = sorted(threshold_map.keys())
            if current_std < keys[0]:
                success_threshold_dbm = threshold_map[keys[0]]
            elif current_std > keys[-1]:
                success_threshold_dbm = threshold_map[keys[-1]]
            else:
                for i in range(len(keys)-1):
                    if keys[i] <= current_std <= keys[i+1]:
                        # ì„ í˜• ë³´ê°„
                        ratio = (current_std - keys[i]) / (keys[i+1] - keys[i])
                        success_threshold_dbm = (threshold_map[keys[i]] +
                                                ratio * (threshold_map[keys[i+1]] - threshold_map[keys[i]]))
                        break

        # ì‹œê°í™” ëª¨ë“œì¼ ë•Œ ê³„ì‚°ëœ ì„ê³„ê°’ ì¶œë ¥ (í™•ì¸ìš©)
        if visualizer:
            print(f"\nSimulation with RSSI_SHADOW_STD = {current_std:.1f}")
            # Rician/Rayleigh ìƒíƒœ í‘œì‹œ ì¶”ê°€
            k_type = "Rayleigh (K=0)" if self.params.RICIAN_K_FACTOR == 0.0 else f"Rician (K={self.params.RICIAN_K_FACTOR})"
            print(f"Fading Model: {k_type}")
            print(f"Success Threshold set to: {success_threshold_dbm:.2f} dBm")
        # â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

        simulation_time = 0.0
        loop_count = 0

        while simulation_time < self.params.TIME_LIMIT:
            loop_count += 1
            new_random_error = np.random.normal(0, self.params.GPS_ERROR_STD, 2)
            drift_factor = self.params.GPS_DRIFT_FACTOR
            gps_error = drift_factor * previous_gps_error + (1 - drift_factor) * new_random_error
            previous_gps_error = gps_error

            reported_pos = true_pos + gps_error
            algo.update_position(reported_pos)

            sensor_delay = max(0.0, np.random.normal(self.params.SENSOR_DELAY_MEAN, self.params.SENSOR_DELAY_STD))
            sensor_error = np.random.normal(0, self.params.SENSOR_ERROR_STD)
            current_rssi = env.get_signal(true_pos) + sensor_error
            simulation_time += sensor_delay

            algo.decide_action(current_rssi)
            # ì•Œê³ ë¦¬ì¦˜ì˜ í˜„ì¬ ìƒíƒœë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹œê°í™”ì— í‘œì‹œí•  ìƒì„¸ ìƒíƒœ ë¬¸ìì—´ ìƒì„±
            current_algo_state_str = algo.state
            if algo.state == "ADAPTIVE_ASCENT":
                if algo.stuck_counter == 0:
                    current_algo_state_str = "ADAPTIVE_ASCENT (ACCEL)"  # ê°€ì† ì¤‘
                else:
                    current_algo_state_str = "ADAPTIVE_ASCENT (ROTATE)"  # íšŒì „ ì¤‘
            elif algo.state == "FINISHED_SUCCESS":
                current_algo_state_str = "SUCCESS"

            # ğŸ” ì•Œê³ ë¦¬ì¦˜ ìƒíƒœ ë””ë²„ê·¸ ì •ë³´
            if visualizer and loop_count <= 10: # 'visualizer'ì¼ ë•Œë§Œ ì¶œë ¥í•˜ë„ë¡ ì¡°ê±´ ì¶”ê°€
                print(
                    f"[Loop {loop_count}] State: {current_algo_state_str} | RSSI: {current_rssi:.2f} dBm | Waypoint: ({algo.waypoint[0]:.1f}, {algo.waypoint[1]:.1f})")

            # waypoint ê³„ì‚° ì¤‘ ìƒíƒœ í‘œì‹œ
            if visualizer:
                visualizer.update(env, true_pos, None, simulation_time, current_rssi, status="Computing Waypoint",
                                  algo_state=current_algo_state_str, next_waypoint=algo.waypoint)

            # â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼
            if not algo.is_finished and current_rssi >= success_threshold_dbm:
                algo.is_finished = True
                algo.state = "FINISHED_SUCCESS"
                # ì„±ê³µ ì‹œì ì˜ RSSI ê°’ ì²´í¬
                rssi_at_success = current_rssi
            # â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²

            # ì´ë™ ë²¡í„° ê³„ì‚° (ì•Œê³ ë¦¬ì¦˜ì´ ì¸ì‹í•˜ëŠ” reported_pos ê¸°ì¤€)
            move_vector = algo.waypoint - true_pos
            move_distance = np.linalg.norm(move_vector)

            # ğŸ” ì²« 10ê°œ ë£¨í”„ - ì´ë™ ë²¡í„° ìƒì„¸ ì •ë³´
            if visualizer and loop_count <= 10: # 'visualizer'ì¼ ë•Œë§Œ ì¶œë ¥í•˜ë„ë¡ ì¡°ê±´ ì¶”ê°€
                print(
                    f"[Loop {loop_count}] reported_pos: ({reported_pos[0]:.1f}, {reported_pos[1]:.1f}) | waypoint: ({algo.waypoint[0]:.1f}, {algo.waypoint[1]:.1f}) | move_vector: ({move_vector[0]:.1f}, {move_vector[1]:.1f})")

            move_direction = move_vector / move_distance if move_distance > 0 else None

            rotation_penalty = 0.0
            if previous_direction is not None and move_distance > 0:
                angle_change = np.arccos(np.clip(np.dot(previous_direction, move_direction), -1.0, 1.0))
                if angle_change > np.deg2rad(10):
                    rotation_penalty = self.params.ROTATION_PENALTY_TIME
            previous_direction = move_direction

            # ì´ë™ì„ ì‘ì€ ë‹¨ê³„ë¡œ ë‚˜ëˆ„ì–´ ì²˜ë¦¬ (ë¶€ë“œëŸ¬ìš´ ì´ë™ íš¨ê³¼)
            time_to_travel = move_distance / self.params.DRONE_SPEED
            num_steps = max(1, int(time_to_travel / 0.05))  # 50msë§ˆë‹¤ ì—…ë°ì´íŠ¸
            step_size = move_distance / num_steps

            for step in range(num_steps):
                if move_distance > 0:
                    true_pos += (move_vector / move_distance) * step_size
                else:
                    true_pos += move_vector

                # GPS ì˜¤ì°¨ ì ìš©í•œ reported_pos ì—…ë°ì´íŠ¸
                new_random_error = np.random.normal(0, self.params.GPS_ERROR_STD, 2)
                drift_factor = self.params.GPS_DRIFT_FACTOR
                gps_error = drift_factor * previous_gps_error + (1 - drift_factor) * new_random_error
                previous_gps_error = gps_error
                reported_pos = true_pos + gps_error

                # âœ… ì¤‘ìš”: algo.pos ì—…ë°ì´íŠ¸í•˜ì—¬ waypoint ê³„ì‚° ê¸°ì¤€ ìµœì‹  ìœ ì§€
                algo.update_position(reported_pos)

                simulation_time += time_to_travel / num_steps

                # ì‹œê°í™” ì—…ë°ì´íŠ¸ (ë§¤ í”„ë ˆì„ë§ˆë‹¤ ë¶€ë“œëŸ½ê²Œ)
                if visualizer:
                    visualizer.update(env, true_pos, None, simulation_time, current_rssi, status="Moving",
                                      algo_state=current_algo_state_str, next_waypoint=algo.waypoint)

                if algo.is_finished:
                    break

            # RSSI_SCAN_TIMEê³¼ rotation_penaltyë¥¼ í”„ë ˆì„ìœ¼ë¡œ ë‚˜ëˆ„ì–´ í‘œì‹œ
            pause_time = self.params.RSSI_SCAN_TIME + rotation_penalty
            if pause_time > 0:
                num_pause_frames = max(1, int(pause_time / 0.05))
                frame_time = pause_time / num_pause_frames
                for _ in range(num_pause_frames):
                    simulation_time += frame_time
                    if visualizer:
                        visualizer.update(env, true_pos, None, simulation_time, current_rssi, status="Scanning RSSI",
                                          algo_state=current_algo_state_str, next_waypoint=algo.waypoint)

            if algo.is_finished:
                break

        # íƒìƒ‰ ì™„ë£Œ ì‹œ ìµœì¢… í™”ë©´ í‘œì‹œ
        if visualizer and algo.is_finished:
            visualizer.update(env, true_pos, None, simulation_time, current_rssi, status="SEARCH Finish",
                              algo_state=current_algo_state_str, next_waypoint=algo.waypoint)
            import time as time_module
            time_module.sleep(2)  # 2ì´ˆê°„ ìµœì¢… í™”ë©´ í‘œì‹œ

        reason = "Success" if algo.is_finished else "Timeout"
        final_distance = np.linalg.norm(true_pos - env.hotspot_pos)

        return SimResult(
            success=algo.is_finished,
            final_distance=final_distance,
            total_travel=algo.get_total_distance(),
            search_time=simulation_time,
            reason=reason,
            waypoint_count=algo.waypoint_count,
            waypoints_at_threshold=waypoints_at_threshold_pass,
            # --- [ìˆ˜ì •] ê²°ê³¼ì— ì„±ê³µ ì‹œì  RSSI í¬í•¨ ---
            rssi_at_success=rssi_at_success
        )

    def run_multiple(self, num_simulations: int = 1000):
        print(f"Starting {num_simulations} simulations...")
        results = []
        start_time = time.time()

        for i in range(num_simulations):
            if (i + 1) % 10 == 0:
                print(f"\rProgress: {i + 1}/{num_simulations}", end="")
            results.append(self.run_single())

        end_time = time.time()
        print(f"\nTotal execution time: {end_time - start_time:.2f} seconds")
        self._analyze_results(results)

    def _analyze_results(self, results: list[SimResult]):
        successful_runs = [r for r in results if r.success]
        success_count = len(successful_runs)
        num_simulations = len(results)

        print("\n--- Final Statistical Analysis ---")
        print(f"Success Rate: {success_count / num_simulations * 100:.1f}%")

        if successful_runs:
            # ë°ì´í„° ì¶”ì¶œ
            success_waypoint_counts = [r.waypoint_count for r in successful_runs]
            success_rssi_values = [r.rssi_at_success for r in successful_runs]
            total_travels = [r.total_travel for r in successful_runs]
            search_times = [r.search_time for r in successful_runs]

            # í†µê³„ ì¶œë ¥
            print(f"\n--- Stats on Successful Runs ({len(successful_runs)} runs) ---")
            print(
                f"Avg Waypoints Generated: {np.mean(success_waypoint_counts):.1f} (Std: {np.std(success_waypoint_counts):.1f})")
            print(
                f"Avg RSSI at Success Moment: {np.mean(success_rssi_values):.2f} dBm (Std: {np.std(success_rssi_values):.2f} dBm)")
            print(f"Avg Total Distance Traveled: {np.mean(total_travels):.2f} m (Std: {np.std(total_travels):.2f} m)")
            print(f"Avg Search Time: {np.mean(search_times):.2f} s (Std: {np.std(search_times):.2f} s)")

        failure_reasons = {}
        for r in results:
            if not r.success:
                failure_reasons[r.reason] = failure_reasons.get(r.reason, 0) + 1

        print("\n--- Failure Analysis ---")
        if not failure_reasons:
            print("No failures recorded.")
        else:
            total_failures = num_simulations - success_count
            if total_failures > 0:
                for reason, count in failure_reasons.items():
                    print(f"- {reason}: {count} times ({count / total_failures * 100:.1f}%)")

# --------------------------------------------------------------------------
# 6. Main Execution Block
# --------------------------------------------------------------------------
def main():
    mode = input(
        "Select mode:\n"
        " [1] Single Simulation (Visualized)\n"
        " [2] Multi-Simulation (Statistical Analysis for RSSI_SHADOW_STD = 1, 3, 5)\n"
        " >> "
    )

    if mode == '1':
        print("\nStarting single simulation...")

        # ë°°ì† ì„ íƒ
        print("\në°°ì†ì„ ì„ íƒí•˜ì„¸ìš”:")
        print(" [1] 0.5ë°°ì† (ëŠë¦¼)")
        print(" [2] 1.0ë°°ì† (ì‹¤ì‹œê°„)")
        print(" [3] ìµœëŒ€ì† (ê°€ì¥ ë¹ ë¦„)")
        speed_choice = input("ì„ íƒ [ê¸°ë³¸ê°’: 2]: ").strip()

        speed_map = {'1': 0.5, '2': 1.0, '3': 100.0}  # 100ë°° = ìµœëŒ€í•œ ë¹ ë¥´ê²Œ
        time_scale = speed_map.get(speed_choice, 1.0)

        speed_names = {'0.5': '0.5ë°°ì†', '1.0': '1.0ë°°ì†', '100.0': 'ìµœëŒ€ì†'}
        print(f"âœ… {speed_names.get(str(time_scale), '1.0ë°°ì†')}ë¡œ ì‹œì‘í•©ë‹ˆë‹¤...")

        params = SimParams()
        runner = SimulationRunner(params)
        visualizer = SimulationVisualizer(time_scale=time_scale, view_radius_m = 100.0)
        result = runner.run_single(visualizer=visualizer)
        visualizer.close()

        print("\n--- Simulation Result ---")
        print(f"Success: {result.success} (Reason: {result.reason})")
        if result.success:
            print("\n--- On Success ---")
            print(f"Waypoints Generated: {result.waypoint_count}")
            print(f"RSSI at Success Moment: {result.rssi_at_success:.2f} dBm")
            print(f"Total Distance Traveled: {result.total_travel:.2f} m")

        print("\n--- General Info ---")
        print(f"Final Distance to Hotspot: {result.final_distance:.2f} m")
        print(f"Total Search Time: {result.search_time:.2f} s")

    elif mode == '2':
        shadow_std_values = [1.0, 3.0, 5.0]
        for std_val in shadow_std_values:
            print("\n" + "=" * 50)
            print(f"### Starting Simulation for RSSI_SHADOW_STD = {std_val:.1f} ###")
            print("=" * 50)
            params = SimParams()
            params.RSSI_SHADOW_STD = std_val
            runner = SimulationRunner(params)
            runner.run_multiple(1000)

    else:
        print("Invalid input. Please enter 1 or 2.")


if __name__ == "__main__":
    main()
